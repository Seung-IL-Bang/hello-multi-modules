### 사용한 디자인 패턴

1. **템플릿 메소드 패턴**: `AbstractPaymentProcessor` 클래스에서 결제 처리의 기본 흐름을 정의하고 각 단계를 추상 메소드로 선언하여 하위 클래스에서 구현하도록 했습니다. 이를 통해 결제 처리 흐름은 유지하면서 결제 수단별 구체적인 처리 방식을 다르게 구현할 수 있습니다.
2. **팩토리 패턴**: `PaymentProcessorFactory`를 통해 클라이언트가 구체적인 결제 처리기 구현체를 직접 생성하지 않고 결제 수단 타입을 기반으로 적절한 처리기를 생성하도록 했습니다.
3. **데코레이터 패턴**: 로깅, 보안 검증과 같은 부가 기능을 `PaymentProcessorDecorator`를 통해 구현하여 기존 결제 처리기에 동적으로 기능을 추가할 수 있도록 했습니다.
4. **빌더 패턴**: `PaymentResult.Builder`를 통해 복잡한 결제 결과 객체의 생성을 간소화했습니다.

### SOLID 원칙 적용

1. **단일 책임 원칙(SRP)**: 각 클래스가 명확한 하나의 책임을 가지도록 설계했습니다. 예를 들어, 결제 처리는 `PaymentProcessor` 구현체에서, 로깅은 `LoggingPaymentDecorator`에서, 보안 검증은 `SecurityPaymentDecorator`에서 담당합니다.
2. **개방-폐쇄 원칙(OCP)**: 새로운 결제 수단이 추가될 때 기존 코드를 수정하지 않고 새로운 `PaymentProcessor` 구현체를 추가하는 방식으로 확장 가능합니다. 부가 기능도 데코레이터를 통해 기존 코드 수정 없이 추가할 수 있습니다.
3. **리스코프 치환 원칙(LSP)**: 모든 `PaymentProcessor` 구현체는 인터페이스의 계약을 준수하며, 상위 타입인 `PaymentProcessor`로 참조해도 동작이 보장됩니다.
4. **인터페이스 분리 원칙(ISP)**: `PaymentProcessor` 인터페이스는 결제 처리에 필요한 최소한의 메소드만 포함하고 있습니다.
5. **의존성 역전 원칙(DIP)**: 높은 수준의 모듈(`PaymentService`)이 저수준의 모듈(`CardPaymentProcessor` 등)에 직접 의존하지 않고, 추상화(`PaymentProcessor` 인터페이스)에 의존합니다.

이 설계는 새로운 결제 수단이나 부가 기능을 쉽게 추가할 수 있는 유연한 구조를 제공하며, 결제 처리 과정에서의 각 단계가 명확히 분리되어 있어 코드의 가독성과 유지보수성이 향상됩니다.